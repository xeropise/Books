## 아키텍처



### 4개의 영역

- <u>표현</u>

  - 표현 영역 또는 UI 영역

    

  - 사용자의 요청을 받아 응용 영역에 전달하고 응용 영역의 처리 결과를 다시 사용자에게 보여주는 역할을 한다.

    

  - 웹 애플리케이션에서 표현 영역의 사용자는 웹 브라우저를 사용하는 사람일 수도 있고, REST API를 호출하는 외부 시스템 일 수도 있다.

    

  - HTTP 요청을 응용 영역이 필요로 하는 형식으로 변환해서 응용 영역으로 전달

    - 웹 브라우저가 요청 파라미터로 전송한 데이터를 응용 서비스가 요구하는 형식의 객체타입으로 변환해서 전달

    

  - 응용 영역의 응답을 HTTP 응답으로 변환해서 전송

    - 응용 서비스가 리턴한 결과를 JSON 형식으로 변환해서 HTTP 응답으로 웹 브라우저에 전달

    

- <u>응용</u>

  - 표현 영역을 통해 사용자의 요청을 전달받는 영역으로, 시스템이 사용자에게 제공해야 할 기능을 구현한다.

    

  - '주문등록', '주문취소', '상품 상세 조회' 같은 기능을 구현한다.

    

  - 응용 영역은 기능을  구현하기 위해 도메인 영역의 도메인 모델을 사용한다.

    

  ```java
  public class CancelOrderService {
   	
    @Transactional
    public void cancelOrder(String orderId) {
      Order order = findOrderById(orderId);
      if (order == null) throw new OrderNotFoundException(orderId);
      order.cancel();
    }
  }
  ```

  

  - 로직을 직접 수행한다기보다는 도메인 모델에 로직 수행을 위임한다.

  

  

- <u>도메인 영역</u>

  - 도메인 영역은 도메인 모델을 구현한다.

    

  - 이전의  Order, OrderLine, ShippingInfo 같은 도메인 모델이  이 영역에 위치한다.

    

  - 도메인 모델은 도메인의 핵심 로직을 구현한다.

    - 예로 주문 도메인의 경우 '배송지 변경', '결제 완료', '주문 총액 계산' 과 같은  핵심 로직을 도메인 모델에서 구현한다.

      

- <u>인프라스트럭처 영역</u>

  - 구현 기술에 대한 것을 다룬다.

    

  - RDBMS 연동을 처리하고, 메시징 큐에 메시지를 전송하거나 수신하는 기능, 몽고 디비나 HBase를 사용한 데이터베이스 연동 처리를 한다.

    

  - SMTP를 이용한 메일 발송 기능을 구현하거나 HTTP 클라이언트를 이용해서 REST API를 호출하는 것도 처리한다. 

    

  - 논리적인 개념을 표현하기보다는 실제 구현을 다룬다.



- 도메인 영역, 응용 영역, 표현 영역은 구현 기술을 사용한 코드를 직접 만들지 않고, 인프라스트럭처 영역에서 제공하는 기능을 사용해서 필요한 기능을 개발한다.

  - 응용 영역에서 DB에 보관된 데이터가 필요하면 인프라스트럭처 영역의  DB 모듈을 사용해서 데이터를 읽어 온다.

  

  - 비슷하게 외부에 메일을 발송해야하면 인프라스트럭처가 제공하는 SMTP 연동 모듈을 이용해서 메일을 발송한다.

<br>

***

### 계층 구조 아키텍처

<img width="154" alt="img" src="https://user-images.githubusercontent.com/50399804/127292859-f50c4301-cfca-44fd-93c8-0e204406f354.png">

- 표현 영역과 응용 영역은 도메인 영역을 사용 한다. 도메인 영역은 인프라스트럭처 영역을 사용하므로 계층 구조를 적용하기에 적당해 보인다.

  

- 계층 구조는 그 특성 상 상위 계층에서 하위 계층으로의 의존만 존재하고 하위 계층은 상위 계층에 의존하지 않는다.

  

- 짚고 넘어가야 할 점으로는 표현, 응용, 도메인 계층이 상세한 구현 기술을 다루는 인프라스트럭처 계층에 종속된다.
  - 예로 도메인의 가격 계산을 해 보자. 할인 금액 계산 로직이 복잡해지면 객체 지향으로 로직을 구현하는 것보다 외부 엔진을 사용하는 것이 알맞을 때가 있다.

  ```java
  public class DroolsRuleEngine {
    private KieContainer kContainer;
    
    public DroolsRuleEngine() {
      KieServices ks = KieServices.Factory.get();
      kContainer =.ks.getKieClasspathContainer();
    }
    
    public void evaluate(String sessionName, List<?> facts) {
      KieSession kSession = kContainer.newkieSession(sessionName);
      try {
        facts.forEach(x -> kSession.insert(x));
        kSession.fireAllRules();
      } finally {
        kSession.dispose();
      }
    }
  }
  ```

  ```java
  public class CalculateDiscountService {
    private DroolsRuleEngine ruleEngine;
    
    public CalculateDiscountService() {
      ruleEngine = new DroolsRuleEngine();
    }
    
    public Money calculateDiscount(List<OrderLine> orderLines, String customerId) {
      Customer customer = findCustomer(customerId);
      
      MutableMoney money = new MutableMoney(0);
      List<?> facts = Arrays.asList(customer, money);  //Drools 에 특화된 코드		
      facts.addAll(orderLines);												 //Drools 에 특화된 코드
      ruleEngine.evaluate("discountCalculation", facts); //Drools 에 특화된 코드  
      return money.toImmutableMoney();
      
    }
   }
  ```

  

  - 위는 2가지 문제를 가지고 있다. 

    - CalculationDiscountService 만 테스트하기 어렵다. 

      - 테스트하려면 RuleEngine 이 완벽하게 동작해야 한다.

        

      - RuleEngine 클래스와 관련된 설정 파일을 모두 만든 이후에 비로소 CalculateDiscountService 가 올바르게 동작하는지 확인할 수 있다.

        

    - 구현 방식을 변경하기 어렵다.

      - Drools 에 특화된 코드로 인해 Drools 에서 코드를 변경하면 코드를 같이 변경해야 한다.

        

      - 인프라스트럭처 기술에 직접적으로 의존을 하지 않는 것처럼 보여도 실제로는 완전하게 의존하고 있다. 



***

### DIP(Depedency Inversion Principle : 의존 역전 원칙)

- 추상화한 인터페이스를 통해 계층 구조 아키텍처에서 일어나는 의존 문제점을 해결할 수 있다. 

```java
public interface RuleDiscounter {
  public Money applyRules(Customer customer, List<OrderLine> orderLines)
}
```

```java
public class CalculateDiscountService {
  private RuleDiscounter ruleDiscounter; // 인터페이스 사용
  
  public CalculateDiscountService(RuleDiscounter ruleDiscounter) {
    this.ruleDiscounter = ruleDiscounter;
  }
  
  public Money calculateDiscount(List<OrderLine> orderLines, String customerId) {
    Customer customer = findCustomer(customerId);
    return ruleDiscounter.applyRules(customer, orderLines);
  }
}
```

```java
public class DroolsRuleDiscounter implements RuleDiscounter {
  private KieContainer kContainer;
  
  public DroolsRuleDiscounter() {
    KieServices ks = KieServices.Factory.get();
    kContainer = ks.getKieClasspathContainer();
  }
  
  @Override
  public Money applyRule(Customer customer, List<OrderLines> orderLines) {
    KieSession kSession = kContainer.newkieSession("discountSession");
    try {
      ... 
      kSession.fireAllRules();
    } finally {
      kSession.dispose();
    }
    return money.toImmutableMoney();
  }
 }
```



- 구현 기술 교체 문제는 고수준 모듈이 더 이상 저수준 모듈(예로 인프라 스트럭처)에 의존하지 않고 구현을 추상화한 인터페이스에 의존하므로 실제 사용할 저수준 구현 객체는 의존 주입을 이용해서 전달받을 수 있다.

```java
// 사용할 저수준 객체 생성
RuleDiscounter ruleDiscounter = new DroolsRuleDiscounter();
// RuleDiscounter ruleDiscounter = new SimpleRuleDisCounter();   사용할 저수준 객체만 변경하면 된다.

// 생성자 방식으로 주입
CalculateDiscountService disService = new CalcualteDiscounterService(ruleDiscounter);
```



- 고수준 모듈의 테스트문제는 대용 객체(Mock Object) 를 사용해서 테스트를 진행할 수 있다.
  - 고수준 모듈이 저수준 모듈에 의존하지 않도록 했기 때문에 실제 구현 없이 테스트를 할 수 있다.

```java
public class CalculateDiscountServiceTest {
  
  @Test(expected = NoCustomerException.class);
  public void noCustomer_thenExceptionShouldBeThrown() {
    // 테스트 목적의 대용 객체
    CustomerRepository stubRepo = mock(CustomerRepository.class);
    when(stubRepo.findById("noCustId")).thenReturn(null);
    
    RuleDiscounter stubRule = (cust, lines) -> null;
    
    // 대용 객체를 주입받아 테스트 진행
    CalculateDiscountService calDisSvc =
      							new CalculateDiscountService(stubRepo, stubRule);
    
    calDivSvc.calculateDiscount(someLines, "noCustId");
  }
}
```



- DIP의 핵심은 고수준 모듈이 저수준 모듈에 의존하지 않도록 하기 위함인데 DIP를 적용한 결과 구조만 보고 저수준 모듈에서 인터페이스를 추출하는 경우를 주의하도록 하자.
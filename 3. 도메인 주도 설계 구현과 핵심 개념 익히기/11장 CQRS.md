### 단일 모델의 단점

- 특정 조회 기능을 구현하려면, 여러 애그리거트에서 데이터를 가져와야 한다.

  - Order에서 주문 정보를, Product에서 상품 이름을, Member 에서 회원 이름과 아이디를...

    

- 조회 화면의 특성상 조회 속도가 빠를수록 좋은데 여러 애그리거트에서 데이터를 가져와야 할 경우 고민 방법을 고민해야 한다.

  - ID 를 이용한 방법은 즉시 로딩 방식과 같은 JPA의 쿼리 관련 최적화 기능을 사용할 수 없음

    - 한 번의 select 쿼리로 조회 화면에 필요한 데이터를 읽어 올 수 없어, 조회 속도에 문제가 발생

      

  - 애그리거트 간의 연관을 직접 참조하는 방식으로 연결해도 고민 거리가 생김

    - 조회 특성 상 같은 연관도 즉시 로딩이나 지연 로딩으로 처리해야 하기 때문

      

  - 경우에 따라 DBMS가 제공하는 전용 기능을 이용해서 조회 쿼리를 작성해야 하므로 JPA의 네이티브 쿼리를 사용해야 할 수도 있음

    

- 시스템의 상태를 변경할 때와 조회할 때 단일 도메인 모델을 사용하기 때문

  - ORM 기법은 도메인의 상태 변경을 구현하는 데는 적합하나 여러 애그리거트로 데이터를 출력하는 기능에는 고려할 것이 많음

    

- 이런 구현 복잡도를 낮추는 간단한 방법

  - __상태 변경을 위한 모델과 조회를 위한 모델을 분리하는 것__



<br>



***

### CQRS

- 시스템이 제공하는 기능은 크게 2가지

  - <u>상태를 변경</u>하는 기능

  - 사용자 입장에서 <u>상태 정보를 조회</u>하는 기능

    

- 도메인 모델 관점에서 상태 변경 기능을 주로 한 애그리거트의 상태를 변경

  

- 상태를 변경하는 범위와 상태를 조회하는 범위가 정확하게 일치하지 않기 때문에 단일 모델로 두 종류의 기능을 구현하려면 모델이 불필요하게 복잡

  - 단일 모델을 사용할 때 발생하는 복잡도를 해결하기 위해 사용하는 방법이 바로 CQRS 

    

- Command Query Responsibility Segration 의 약자

  - 상태를 변경하는 명령을 위한 모델과, 상태를 제공하는 조회를 위한 모델을 분리하는 것

    

- 복잡한 도메인에 적합, 도메인이 복잡할 수록 명령 기능과 조회 기능이 다루는 데이터 범위에 차이가 발생

  - 위의 2기능을 단일 모델로 처리하게 되면 조회 기능의 로딩 속도를 위해 모델 구현이 필요 이상으로 복잡해지는 문제가 발생

    

- CQRS를 도메인에 적용하면 통계를 위한 조회 모델을 별도로 만들기 때문에 조회 때문에 도메인 모델이 복잡해지는 것을 막을 수 있다.

  

- CQRS를 사용하면 각 모델에 맞는 구현 기술을 선택할 수도 있다.

  - 명령 모델은 객체 지향에 기반해서 JPA

    

  - 조회 모델은 Mybatis

    

- 두 데이터 저장소 간의 데이터 동기화는 이벤트를 활용해서 상태 변경내역에 대한 이벤트를 반영하면 된다.

  

- 명령 모델과 조회 모델이 서로 다른 데이터 저장소를 사용할 경우, 데이터 동기화 시점에 따라 구현 방식이 달라질 수 있다.

  - 데이터가 바뀌자마자 변경 내역을 반영해야 한다면동기 이벤트와 글로벌 트랜잭션 사용

    

  - 특정 시간 안에만 동기화하면 된다면 비동기로 데이터를 전송

    

- __웹과 CQRS__

  - 일반적인 웹 서비스는 상태를 변경하는 요청보다 상태를 조회하는 요청이 더 많다.

    

  - 조회 기능 요청 비율이 월등히 높은 서비스를 만드는 개발팀은 조회 성능을 높이기 위해 다양한 기법을 사용한다.

    - 쿼리 최적화를 위해 쿼리 실행 속도 자체를 높힌다.

      

    - 메모리에 조회 데이터를 캐시해서 응답 속도를 높이고, 조회 전용 저장소를 따로 사용하기도 한다.

      

  - 조회 성능을 높이기 위해 다양한 기법을 사용하는 것은 결과적으로 CQRS를 적용하는 것과 같은 효과를 만든다.

    

  - 대규모 트래픽이 발생하는 웹 서비스는 알게 모르게 CQRS를 적용하게 된다.

    

  - 단지, 명시적으로 명령 모델과 조회 모델을 구분하지 않을 뿐이다. 조회 속도를 높이기 위해 별도 처리를 하고 있다면 명시적으로 명령 모델과 조회 모델을 구분하자.

    - 조회 기능 때문에 명령 모델이 복잡해지는 것을 방지할 수 있고, 명령 모델에 관계없이 조회 기능에 특화된 구현 기법을 보다 쉽게 적용할 수 있다. 

      

- __장단점__

  - 장점

    - 명령 모델을 구현할 때 도메인 자체에 집중할 수 있다.

      - 복잡한 도메인은 상태 변경 로직이 복잡한데 명령 모델과 조회 모델을 구분하면 조회 성능을 위한 코드가 명령 모델에 없으므로, 도메인 로직에 집중 가능

        

      - 명령 모델에서 조회 관련 로직이 사라져 복잡도를 낮춤

        

    - 조회 성능을 향상시키는 데 유리하다.

      - 조회 단위로 캐시기술을 적용할 수 있고, 조회에 특화된 쿼리를 마음대로 사용할 수도 있다.

        

      - 캐시뿐만 아니라 조회 전용 저장소를 사용하면 조회 처리량을 대폭 늘릴 수도 있다.

        

      - 조회 전용 모델을 사용하기 때문에 조회 성능 높이기 윟나 코드가 명령 모델에 영향을 주지 않는다.

        

  - 단점

    - 구현해야 할 코드가 더 많으므로 구현 비용을 따져봐야 한다.

      - 도메인이 복잡하거나 대규모 트래픽이 발생하는 서비스라면 조회 전용 모델을 만드는 것이 향후 유지보수에 유리할 수 있다.

        

      - 도메인이 단순하거나 트래픽이 많지 않은 서비스라면 조회 전용 모델을 만들 이유가 없다.

        

    - 더 많은 구현 기술이 필요하다. 명령모델과 조회 모델을 다른 구현 기술을 사용해서 구현하기도 하고, 경우에 따라 저장소를 사용하기도 한다. 데이터 통기화를 위해 메시징 시스템을 도입해야 할 수도 있다.

      

  - 도메인의 복잡도를 잘 파악하고, 장단점을 잘 고려하여 CQRS 패턴을 적용할지 여부를 잘 결정지어야 한다.
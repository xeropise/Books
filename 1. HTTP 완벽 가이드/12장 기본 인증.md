# 12.기본 인증

- 수백만 명의 사람들이 웹을 통해 개인적인 업무를 보거나 개인적인 데이터에 접근한다.

- 모든 정보나 업무가 공용은 아니기 때문에, 허가된 사람만이 데이터에 접근하고 업무를 처리할 수 있어야 한다.

- 서버가 사용자가 누구인지 식별할 수 있어야 하는데 HTTP는 자체적인 인증 관련 기능을 제공한다.

<br>

---

## 12.1 인증

- 인증이란? 내가 누구인지 증명하는 것이다.

- PIN 번호를 입력하거나 아이디/비밀번호를 입력하는 것을 통해 누구인지 증명하는 것이다.

- 완벽한 인증이란 없다. 누군가가 추측하거나 엿들을 수 있고, 내가 입력한 데이터가 도둑맞거나 위조될 수 있다.

<br>

### 12.1.1 HTTP의 인증요구/응답 프레임워크

- HTTP는 사용자 인증을 하는 데 사용하는 자체 인증요구/응답 프레임워크를 제공한다.

  ![basic-auth_0](https://user-images.githubusercontent.com/50399804/125200809-9c4a0300-e296-11eb-9626-c6a691b7178c.png)

- 웹 애플리케이션이 HTTP 요청 메시지를 받으면, 서버는 요청을 처리하는 대신에 현재 사용자가 누구인지를 알 수 있게 비밀번호 같이 개인 정보를 요구하는 '인증 요구'로 응답할 수 있다.

- 사용자가 다시 요청을 보낼 때는 인증 정보를 첨부해야하고, 만약 인증 정보가 맞지 않으면 서버는 클라이언트에 다시 인증요구를 보내거나 에러를 낼 수 있다. 인증 정보가 맞으면 요청은 문제 없이 처리 완료된다.

<br>

### 12.1.2 인증 프로토콜과 헤더

- HTTP는 제어 헤더를 통해, 다른 인증 프로토콜에 맞추어 확장할 수 있는 프레임워크를 제공한다.

- 나열된 헤더의 형식과 내용은 인증 프로토콜에 따라 달라진다. 물론 인증 프로토콜은 HTTP 인증 헤더에 기술되어 있다.

- HTTP에는 기본 인증과 다이제스트 인증이라는 두 가지 공식적인 인증 프로토콜이 있다.

  ![basic-auth2](https://user-images.githubusercontent.com/50399804/125201120-e97aa480-e297-11eb-83f2-65f68927128e.png)

- 서버가 사용자에게 인증요구를 보낼 때, 서버는 401 Unauthroized 응답과 함께 WWW-Authenticate 헤더를 기술해서 어디서 어떻게 인증할지 설명한다.

- 클라이언트가 서버로 인증하려면, 인코딩된 비밀번호와 그 외 인증 파라미터들을 Authroization 헤더에 담아서 요청을 다시 보낸다.

- 인증 요청이 성공적으로 완료되면, 서버는 정상적인 상태 코드(200) 를 반환하며, 추가적인 인증 알고리즘에 대한 정보를 Authentication-info 헤더에 기술할 수도 있다.

<br>

### 12.1.3 보안 영역

- HTTP가 어떻게 각 리소스마다 다른 접근 조건을 다를 수 있을까? 서버가 클라이언트로 인증 요구를 할 때, realm 지시자가 기술되어 있는 WWW-Authenticate 헤더를 통해 웹 서버는 기밀분서를 보안 영역(realm) 그룹으로 나눈다. 이를 통해 보안 영역은 저마다 다른 사용자 권한을 요구할 수 있다.

```
  HTTP/1.0 401 Unauthorized
  WWW-Authenticate: Basic realm="Corporate Financials"
```

<br>

---

## 12.2 기본 인증 (Basic Authentication)

- 가장 잘 알려진 HTTP 인증 규약으로, 거의 모든 주요 클라이언트와 서버에 기본 인증이 구현되어 있다.

- 웹 서버는 클라이언트의 요청을 거부하고 유효한 사용자 이름과 비밀번호를 요구할 수 있다.

- 401 상태 코드(Unauthroized)와 함께, 클라이언트가 접근하려고 했던 보안 영역을 WWW-Authenticate 에 기술해서 응답하여 인증 요구를 시작한다.

- 응답 받은 브라우저는 계정과 비밀번호를 입력할 수 있는 대화상자를 열고 브라우저는 사용자가 입력한 계정명과 비밀번호를 Authroziation 요청 헤더 안에 암호화 ( 계정명:비밀번호 형식을 Base64로 인코딩 ) 해서 서버로 다시 보낸다.

  ![basic-auth3](https://user-images.githubusercontent.com/50399804/125201507-b0dbca80-e299-11eb-9721-af3b1071f288.png)

- 기본 인증 프로토콜은 Authentication-info 헤더를 사용하지 않는다.

### 12.2.1 프록시 인증

- 중개역할을 하는 프록시 서버를 통해 인증할 수도 있다. 프록시 서버에서 접근 정책을 중앙 관리 할 수 있기 때문에, 회사 리소스 전체에 대한 통합적인 접근 제어를 하기 위해 프록시 서버를 사용하면 좋다.

- 프록시 인증은 웹 서버의 인증과 헤더와 상태 코드만 다르고 절차는 같다.

<br>

| 웹 서버                 | 프록시 서버               |
| ----------------------- | ------------------------- |
| 비 인증 상태 코드 : 401 | 비 인증 상태 코드 : 407   |
| WWW-Authenticate        | Proxy-Authenticate        |
| Authorization           | Proxy-Authorization       |
| Authentication-Info     | Proxy-Authentication-Info |

<br>

## 12.3 기본 인증의 보안 결함

- 기본 인증은 단순하고 편리하지만 안심할 수 없다. SSL 같은 암호 기술과 혼용하여 사용한다.

- 보안 결함은 다음과 같다.

  1. 기본 인증은 사용자 이름과 비밀번호를 쉽게 디코딩할 수 있는 형식으로 네트워크에 전송한다. base-64 디코딩 절차를 통해 쉽게 얻어낼 수 있다. 비밀번호를 그대로 보내는 것과 다름이 없다.
     누군가 가로챈다면 매우 위험하므로 모든 HTTP 트랜잭션을 SSL 암호화 채널을 통해 보내거나, 보안이 더 강화된 다이제스트 인증 같은 프로토콜을 사용하는 것이 좋다.

  <br>

  2. 보안 비밀번호가 디코딩하기에 더 복잡한 방식으로 인코딩되어있다고 하더라도, 사용자 이름과 비밀번호를 캡처한 다음에 그대로 원 서버에 보내서 인증에 성공하고 서버에 접근할 수 있다.

  <br>

  3. 회사의 인트라넷 접근 제어나 개인화된 콘텐츠 같이 보안이 뚫리더라도 치명적이지 않는 애플리케이션에 사용되더라도, 사용자들은 모든 인증요청마다 다른 비밀번호를 사용하지 않으므로 이를 악용할 수 있다.

  <br>

  4. 메시지의 인증 헤더를 건드리지는 않지만, 다른 부분을 수정해서 트랜잭션의 본래 의도를 바꿔버리는 프록시나 중개자가 중간에 개입하는 경우, 기본 인증은 정상적인 동작을 보장하지 않는다.

  <br>

  5. 기본 인증은 가짜 서버의 위장에 취약하다. 만약 사용자가 가짜 서버나 가짜 게이트에 연결되어 있는데도, 사용자는 기본 인증을 수행하는 검증된 서버에 연결되어 있다고 믿고 있다면, 공격자는 사용자에게 비밀번호를 요청하고 그것을 나중에 사용할 목적으로 저장한 다음 에러가 난 척을 할 것이다.

# 다이제스트 인증

- 기본 인증(Basic Authentication)과 호환되는 더 안전한 대체제로서 개발됨

- 비밀번호를 절대로 네트워크를 통해 평문으로 전송하지 않음

- 인증 체결을 가로채서 재현하려는 악의적인 사람들을 차단

- 구현하기에 따라서, 메시지 내용 위조를 막는것이 가능

- 그 외 몇몇 잘 알려진 형태의 공격을 막음

- 다이제스트 인증이 가능한 가장 안전한 프로토콜은 아님

---

## 다이제스트 인증의 동작

- 클라이언트가 보호된 문서를 요구

- 서버는 클라이언트가 비밀번호를 알고 있음을 스스로 증명하여 신원을 인증하기 전까지 문서를 제공하는 것을 거부, 클라이언트에게 사용자 이름과 요약된 형태의 비밀번호를 요구

- 클라이언트는 비밀번호의 **요약**을 전달하여 자신이 비밀번호를 알고 있음을 증명, 서버는 모든 사용자의 비밀번호를 알고 있으므로, 클라이언트가 제공한 요약과 서버가 스스로 계싼한 요약이 일치하는지 비교하여 사용자가 비밀번호를 알고 있는지 확인할 수 있다. 비밀번호를 모르는 사람은 올바른 요약을 만들어내기 쉽지 않다.

- 서버는 클라이언트가 제공한 요약과 서버가 내부적으로 계산한 요약을 비교, 일치하면 이는 클라이언트가 비밀번호를 알고 있는 것이다. (혹은 희귀하게 찍어 맞춘 것이다.) 서버가 일치 여부를 확인하면, 클라이언트에게 문서가 제공되고, 모든 과정에서 비밀번호는 결코 네트워크를 통해 전송되지 않는다.

![http-13-4-638](https://user-images.githubusercontent.com/50399804/125303504-d2a38300-e367-11eb-8c5b-c464e761a819.jpg)

<br>

---

## 요약?

- 정보 본문의 압축 으로 입력한 비밀번호를 MD5 함수를 통해 원래 길이와 상관없는 128비트으로 변환한 것으로 단방향 함수로 동작한다.

<br>

## 재전송 방지를 위한 난스(nonce) 사용

- 단방향 요약을 통해 비밀번호를 그대로 전송해야 할 필요성에서 벗어낫으나 요약 자체로는 보안 위험에서 벗어날 수 없다.

- 비밀번호를 몰라도 요약 자체를 가로채서 서버로 전송할 수 있으므로 요약은 비밀번호와 다름이 없다.

- 이런 문제점을 해결하기 위해 서버는 클라이언트에 난스라고 불리는 값 (예를들면 현재 시간)을 전달하고 이를 비밀번호와 결합하여 재전송시마다 다른 요약이 보내지도록 보장해준다.

- WWW-Authenticate 인증요구에 담겨 서버에서 클라이언트로 넘겨진다.

<br>

---

## 다이제스트 인증 핸드쉐이크

- HTTP 다이제스트 인증 프로토콜은 기본 인증에서 사용하는 것과 비슷한 헤더를 사용하는 강화된 버전의 인증으로 기존 헤더에 몇몇 새 옵션이 추가되었고, 선택적인 헤더인 Authroization-Info가 새로 추가 되었다.

![digest-auth1](https://user-images.githubusercontent.com/50399804/125307264-de447900-e36a-11eb-9512-383ac5818a18.gif)

1. 서버에서 난스 값을 계산한다.

2. WWW-Authenticate 인증요구 메시지에 담아, 서버가 지원하는 알고리즘 목록과 함께 클라이언트에 전송한다.

3. 클라이언트는 알고리즘을 선택하고 비밀번호와 그 외 데이터에 대한 요약을 계산한다. 서버는 그 다음 자신이 계산한 요약과 네트워크로 전송되어 온 요약이 서로 같은지 확인한다.

4. 만약 클라이언트가 대칭적으로 서버에게 클라이언트 난스를 갖고 인증을 요구했다면, 클라이언트 요약이 만들어진다. 또한 서버는 클라이언트가 미리 다음번 요약을 올바르게 생성할 수 있도록 다음번 난스를 미리 계산해서 클라이언트에게 넘겨줄 수도 있다.

# 다이제스트 인증

- 기본 인증(Basic Authentication)과 호환되는 더 안전한 대체제로서 개발됨

- 비밀번호를 절대로 네트워크를 통해 평문으로 전송하지 않음

- 인증 체결을 가로채서 재현하려는 악의적인 사람들을 차단

- 구현하기에 따라서, 메시지 내용 위조를 막는것이 가능

- 그 외 몇몇 잘 알려진 형태의 공격을 막음

- 다이제스트 인증이 가능한 가장 안전한 프로토콜은 아님

---

## 다이제스트 인증의 동작

- 클라이언트가 보호된 문서를 요구

- 서버는 클라이언트가 비밀번호를 알고 있음을 스스로 증명하여 신원을 인증하기 전까지 문서를 제공하는 것을 거부, 클라이언트에게 사용자 이름과 요약된 형태의 비밀번호를 요구

- 클라이언트는 비밀번호의 **요약**을 전달하여 자신이 비밀번호를 알고 있음을 증명, 서버는 모든 사용자의 비밀번호를 알고 있으므로, 클라이언트가 제공한 요약과 서버가 스스로 계산한 요약이 일치하는지 비교하여 사용자가 비밀번호를 알고 있는지 확인할 수 있다. 비밀번호를 모르는 사람은 올바른 요약을 만들어내기 쉽지 않다.

- 서버는 클라이언트가 제공한 요약과 서버가 내부적으로 계산한 요약을 비교, 일치하면 이는 클라이언트가 비밀번호를 알고 있는 것이다. (혹은 희귀하게 찍어 맞춘 것이다.) 서버가 일치 여부를 확인하면, 클라이언트에게 문서가 제공되고, 모든 과정에서 비밀번호는 결코 네트워크를 통해 전송되지 않는다.

![http-13-4-638](https://user-images.githubusercontent.com/50399804/125303504-d2a38300-e367-11eb-8c5b-c464e761a819.jpg)

<br>

---

## 요약?

- 정보 본문의 압축 으로 입력한 비밀번호를 MD5 함수를 통해 원래 길이와 상관없는 128비트으로 변환한 것으로 단방향 함수로 동작한다.

<br>

## 재전송 방지를 위한 난스(nonce) 사용

- 단방향 요약을 통해 비밀번호를 그대로 전송해야 할 필요성에서 벗어낫으나 요약 자체로는 보안 위험에서 벗어날 수 없다.

- 비밀번호를 몰라도 요약 자체를 가로채서 서버로 전송할 수 있으므로 요약은 비밀번호와 다름이 없다.

- 이런 문제점을 해결하기 위해 서버는 클라이언트에 난스라고 불리는 값 (예를들면 현재 시간)을 전달하고 이를 비밀번호와 결합하여 재전송시마다 다른 요약이 보내지도록 보장해준다.

- WWW-Authenticate 인증요구에 담겨 서버에서 클라이언트로 넘겨진다.

<br>

---

## 다이제스트 인증 핸드쉐이크

- HTTP 다이제스트 인증 프로토콜은 기본 인증에서 사용하는 것과 비슷한 헤더를 사용하는 강화된 버전의 인증으로 기존 헤더에 몇몇 새 옵션이 추가되었고, 선택적인 헤더인 Authroization-Info가 새로 추가 되었다.

![digest-auth1](https://user-images.githubusercontent.com/50399804/125307264-de447900-e36a-11eb-9512-383ac5818a18.gif)

1. 서버에서 난스 값을 계산한다.

2. WWW-Authenticate 인증요구 메시지에 담아, 서버가 지원하는 알고리즘 목록과 함께 클라이언트에 전송한다.

3. 클라이언트는 알고리즘을 선택하고 비밀번호와 그 외 데이터에 대한 요약을 계산한다. 서버는 그 다음 자신이 계산한 요약과 네트워크로 전송되어 온 요약이 서로 같은지 확인한다.

4. 만약 클라이언트가 대칭적으로 서버에게 클라이언트 난스를 갖고 인증을 요구했다면, 클라이언트 요약이 만들어진다. 또한 서버는 클라이언트가 미리 다음번 요약을 올바르게 생성할 수 있도록 다음번 난스를 미리 계산해서 클라이언트에게 넘겨줄 수도 있다.

<br>

---

## 요약 계산

- 다이제스트 인증의 핵심은 공개된 정보, 비밀 정보, 시한부 난스 값을 조합한 단방향 요약이다.

- 요약은 단방향 해시함수 H(d)와 요약 함수 KD(s,d)로 계산 된다. (여기서 d는 데이터, s는 비밀을 말한다.)

- 비밀번호 등 보안 정보를 담고 있는 데이터 덩어리 A1, 요청 메시지의 비밀이 아닌 속성을 담고 있는 데이터 덩어리 A2

- A1,A2 두 조각 데이터는 요약을 생성하기 위해 H와 KD에 의해 처리된다.

<br>

### H(d)와 KD(s,d) 알고리즘

- 다이제스트 인증은 여러 가지 요약 알고리즘을 선택할 수 있도록 지원한다.

- MD5와 MD5-sess 가 제안된 두 알고리즘이고, 만약 정해지지 않았다면 MD5가 기본값이다.

<br>

```
H(d) = MD5(d)
KD(s, d) = H(s:d)
```

<br>

### 보안 관련 데이터(A1)

- 사용자 이름, 비밀번호, 보호 영역, 난스와 같은 비밀 보호 정보로 이루어져 있다.

```
MD5: A1 = <사용자>:<영역>:<비밀번호>
MD5-sess: A1 = MD5(<사용자>:<영역>:<비밀번호>):<난스>:<c난스>
```

<br>

### 메시지 관련 데이터(A2)

- URL, 요청 메서드, 메시지 엔터디 본문과 같은 메시지 자체의 정보를 나타낸다.

- 메서드, 리소스, 메시지의 위조를 방지하기 위해 사용된다.

- 선택된 보호 수준(quality of protection, qop)에 따라 두 가지 사용법이 정의된다.

```
정의되지 않음:  <요청메서드>:<uri 지시자 값>
auth:  <요청메서드>:<uri 지시자 값>
auth-int:  <요청메서드>:<uri 지시자 값>
```

<br>

---

## 보호 수준(Quality of Protection) 향상

- qop 필드는 WWW-Authenticate, Authorization, Authentication-Info에 모두 존재 할 수 있다.

- qop 필드는 클라이언트와 서버가 어떤 보호 기법을 어느 정도 수준으로 사용할 것인지 협상할 수 있게 해 준다.

- 서버는 우선 WWW-Authenticate 헤더에 qop 옵션을 쉼표로 구분된 목록 형태로 내보내고, 클라이언트는 그 옵션들 중 지원할 수 있으면서 동시에 자신의 요구에도 맞는 것을 선택하여, 그것을 Authorization 헤더의 qop 필드에 담아 돌려 준다.

- RFC 2617 은 기본적으로 두 가지 초기 보호수준 값을 정의하고 있는데, 하나는 인증을 의미하는 'auth', 다른 하나는 인증 및 메시지 무결성 보호를 의미하는 'auth-init' 이다.

    <img width="519" alt="ch13_7" src="https://user-images.githubusercontent.com/50399804/125312655-70e71700-e36f-11eb-9f73-8e61a0b9f1e3.png">

<br>

---

## 실제 상황에 대한 고려

- 다이제스트 인증 작업을 할 떄 고려해야 할 것이 몇가지 있다.

<br>

1. 다중 인증 요구

- 서버가 클라이언트의 사양을 모르므로 기본 및 다이제스트 인증 요구를 모두 보낼 수 있는데, 클라이언트는 반드시 자신이 지원할 수 있는 가장 강력한 인증 메커니즘을 선택해야 한다.

- WWW-Authenticate 나 Proxy-Authenticate 헤더가 둘 이상 제공되거나 헤더 들에 인증요구가 둘 이상 포함될 수 있다.

<br>
<br>

2. 오류 처리

   - 인증 서버는 반드시 uri 지시자가 가리키는 리소스가 요청줄에 명시된 리소스와 같음을 확인해야 한다. 만약 다르다면 서버는 400 Bad Request 에러를 반환하는 것이 좋다. (공격에 대한 징후일 수 있으므로, 이런 에러에 대해 로그를 남기는 것도 좋다. 프록시 변경에 대한 고려)

<br>
<br>

3. 보호 공간(Protection Space)

   - realm 은 접근한 서버의 루트 URL과 결합하여, 보호 공간을 정의한다.
   - realm 은 일반적으로 원 서버에 의해 할당되는 문자열이다.

   - 보호공간의 구체적인 계산은 인증 메커니즘에 달려있다.

     - 기본 인증

       - 클라이언트 요청 URI와 그 하위의 모든 경로는 같은 보호 공간에 있는 것으로 가정한다. 클라이언트 이 공간에서 서버로부터의 또 다른 인증 요구를 기다리지 않고 미리 리소스에 대한 인가를 받을 수 있다.

     - 다이제스트 인증

       - 인증요구의 WWW-Authenticate: domain 필드는 보호 공간을 보다 엄밀하게 정의한다. domain 필드는 작은 따옴표로 묶인 URI의 공백으로 분리된 목록이다.

       - domain 목록은 모든 URI와 논리적으로 그 하위에 위치한 모든 URI는 같은 보호 공간에 있는 것으로 가정한다. 만약 domain 필드가 없거나 빈 값이라면, 인증을 요구한 서버의 모든 URI는 그 보호 공간에 있는 것이다.

<br>
<br>

4. URI 다시 쓰기

   - 프록시가 가리키는 리소스의 변경 없이 구문만 고쳐서 URI를 다시 쓰기도 한다.

   - 호스트 명은 정규화되거나 IP 주소로 대체될 수 있다.

   - 문자들은 \"%" escape 형식으로 대체될 수 있다.

   - 특정 원 서버로부터 가져오는 리소스에 영향을 주지 않는, 타입에 대한 추가 속성이 URI의 끝에 붙거나 중간에 삽입될 수 있다.

   - 프록시가 URI 를 변경할 수 있는 동시에 다이제스트 인증은 URI 값의 무결성을 검사하므로, 다이제스트 인증은 이러한 변경에 의해 실패할 수 있다.

<br>
<br>

5. 캐시

   - 어떤 공유 캐시가 Authorization 헤더를 포함한 요청과 그에 대한 응답을 받은 경우, 다음의 두 [Cache-Control](https://developer.mozilla.org/ko/docs/Web/HTTP/Headers/Cache-Control) 지시자 (must-revalidate, public) 중 하나가 응답에 존재하지 않는 한 다른 요청에 대해 그 응답을 반환해서는 안 된다.

   - 만약 원 서버의 응답이 "must-revalidate" Cache-Control 지시자를 포함한 경우, 캐시는 그 응답의 엔티티를 다음 요청에 대한 응답을 위해 활용할 것이다. 그러나 원 서버가 새 요청을 인증할 수 있도록, 우선 그 요청의 헤더를 이용해서 재검사를 수행해야 한다.

   - 만약 원 서버의 응답이 "public" Cache-Control 지시자를 포함한 경우, 응답 엔티티는 그 다음에 오는 임의의 요청에 대한 응답으로 반환될 수 있다.

   - (글 작성 기준, 캐시에 대해 잘 몰라서 솔직히 이해는 안간다. 정리가 필요)

<br>

---

## 보안에 대한 고려사항

- 헤더 부당 변경
- 재전송 공격
- 다중 인증 메커니즘
- 사전(dictionary) 공격
- 악의적인 프락시와 중간자 공격
- 선택 평문 공격
- 비밀번호 저장

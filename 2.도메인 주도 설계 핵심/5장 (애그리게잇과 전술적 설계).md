## 애그리게잇과 전술적 설계

![Aggregate](https://user-images.githubusercontent.com/50399804/127100663-dcfd0872-14aa-4448-912d-c35dff32aab8.png)



- 바운디드 컨텍스트 안의 개념들에 대해  좀 더 자세하게 다뤄보도록 하자. 

  

- 바운디드 컨텍스트 안에 각각의 개념들 (ex) 상품, 주문 등등)을 애그리게잇(Aggregate) 이라고 한다.

  - 애그리게잇은 1개 이상의 엔티티(Entity) 로 구성되고, 그 중 한 엔티티는 애그리게잇 루트라고 부른다. 애그리게잇은 그 구성에 값 객체(Value Object) 를 포함할 수 있다.



> 엔티티와 값 객체
>
> 엔티티 => 독립적인 것, 같은 형태를 디거나 다른형태의 엔티티들과의 특성을 구별할 수 있는 고유한 식별성을 갖는다.
>
> 값 객체 => 불변의 개념적 완전성을 모델링한다. 모델에서 값은 그야말로 값, 엔티티와 달리 고유한 식별성이 없으며, 값 형태로 캡슐화된 속성을 비교함으로써 동일함이 결정된다.



- 애그리게잇 루트 엔티티는 애그리게잇 안의 다른 모든 요소를 소유 한다. 애그리게잇이 모델링하는 개념적 완전성을 적절하게 표현할 수 있는 명칭으로 루트 엔티티 명칭을 정의해야 한다.

  

- 각 애그리게잇은 일관성 있는 트랜잭션 경계를 형성하는데, 트랜잭션 제어가 데이터베이스에 커밋될 때, 한 에그리게잇 내의 모든 구성 요소는 반드시 비즈니스 규칙을 따르면서 일관성 있게 처리된다는 것을 의미한다.

  

- 다만, 에그리게잇 내에 트랜잭션 이후 일관성이 지켜질 필요가 없는 다른 요소를 포함해서는 안 된다는 뜻은 아니다. 에그리게잇은 개념적으로 완전하게 모델링해야 하기 때문이다. 하지만 트랜잭션의 일관성에 신경을 써야 하는 것은 분명하다.



> 넓은 의미의 트랜잭션
>
> - 애그리게잇에 대한 변경을 독립시키고, 소프트웨어가 언제나 충실히 준수해야 하는 규칙인 비즈니스 불변성을 각 비즈니스 오퍼레이션에 맞게 일관성을 보장하는 방법이다.
>
>   
>
> - 이 요구사항을 원자적 데이터베이스 트랜잭션으로 처리하거나 다른 방법으로 처리하는 것과는 상관없이,  애그리게잇의 상태나 이벤트 소싱은 항상 안전하고 정확하게 트랜잭션으로 처리하고 관리해야 한다.



- __트랜잭션 경계를 두는 이유는 비즈니스 때문인데, 애그리게잇이 유효한 상태인지, 아닌지를 결정하는 것은 비즈니스와 관련되어 있는 일이기 때문이다. 애그리게잇이 완전하고 유효한 상태로 저장되지 않는다면, 수행된 비즈니스 오퍼레이션은 비즈니스 규칙에 어긋난 것으로 간주해야 한다.__

  

<br>

***

### 애그리게잇 경험 법칙

- 애그리게잇 설계의 4가지 기본 규칙

  - 애그리게잇 경계 내에서 비즈니스 불변사항들을 보호하라. 

    - 트랜잭션이 커밋될 때 비즈니스의 일관성이 지켜지는 것에 기반을 두고 애그리게잇 구성 요소를 결정해야 한다는 의미

      

    - 예로 Task 인스턴스의 남은시간이 0일 때, BacklogItem의 status 는 반드시 Done 으로 설정되어야 함.

      

  - 작은 애그리게잇을 설계하라.

    - 애그리게잇의 메모리 사용량과 트랜잭션 범위가 비교적 작아야 함을 강조

      

    - 큰 애그리게잇을 설계하지말고, 가능하면 작은 단위로 설계할 것 (작은 단위가 훨씬 더 자주, 성공적인 트랜잭션을 수행할 것이라는 것)

      

    - 연관된 각 작업이 한 명의 개발자가 관리할 수 있을 만큼 작기 떄문에 각 애그리게잇이 좀 더 쉬워지는 부가적인 이득을 얻을 수 있으며, 테스트 또한 보다 더 쉬워질 것이다.

      

    - 애그리게잇을 설계할 때 고려해야 하는 또 다른 사항은 SRP(Single Responsibility Principle) 라는 단일 책임의 원칙이다. 만일 애그리게잇이 너무 많은 일을 한다면, 이후 애그리게잇의 크기에 대해 재논의할 가능성이 크다.

      

  - 오직 ID(식별자) 를 통해 다른 애그리게잇을 참조하라. 

    - 애그리게잇을 작게 유지하고, 동일한 트랜잭션 내에 여러 애그리게잇을 수정하려는 접근을 방지해준다.

      

    - 더 적은 메모리 요구와 레포지터리로부터의 빠른 로딩을 통해 애그리게잇 설계를 작고 효율적으로 유지할 수 있게 해준다. 또한 동일한 트랜잭션 내에 다른 애그리게잇을 수정하지 않는 규칙이 잘 지켜지도록 해준다.

      

    - 애그리게잇을 RDBMS, 문서 데이터베이스, key/value 리포지터리 그리고 데이터 그리드/패브릭 과 같은 다른 형태의 저장 메커니즘으로도 쉽게 저장할 수 있다. (JSON 기반의 리포지터리 사용을 선택저으로 결정할 수 있다는 것을 말한다.)

      

  - 결과적 일관성을 사용해 다른 애그리게잇을 갱신하라.

    - 2개의 연계되어 수행되는 애그리게잇에서 하나의 애그리게잇에서 새롭게 할당된 ID가 다른 애그리게잇 관점에서 연계되어 제대로 실행되었는지 알 수 있는 방법?

      - 도메인 이벤트를 발행하여, 한 트랜잭션의 완료 후 상태를 유지한다.

        

    - 도메인 이벤트는 애그리게잇에 의해 발행되고, 이에 관심이 있는 바운디드 컨텍스트는 이를 전달 받는다. 이처럼 메시징 메커니즘은 구독을 통해 관심 있는 파티들에게 도메인 이벤트를 전달한다. 관심 있는 바운디드 컨텍스트는 도메인 이벤트를 발행한 컨텍스트일 수도 있고, 다른 바운디드 컨텍스트일 수도 있다.



<br>

***

### 애그리게잇 모델링

- 도메인 모델 관련, 애그리게잇 구현 작업을 할 때 만나기 쉬운 문제점들

  - 빈약한 도메인 모델(Anemic Domain Model)

    - 모든 애그리게잇이 비즈니스 행위가 아닌 게터(getter)와 세터(setter) 접근자만을 갖는 것

    - 비즈니스보다는 기술적인 부분에 초점을 맞췃을 때 발생

    - 빈약한 도메인 모델을 설계하는 것은 도메인 모델이 주는 혜택을 받지 못하고, 모든 오버헤드를 떠안아버림

      

  - 비즈니스 로직이 도메인 모델을 넘어 애플리케이션 서비스까지 새어 나가지 않도록 주의해야 한다. 

  

  - 단, 함수형 프로그래밍을 사용하여 DDD를 적용하고자 하는 경우는 해당되지 않거나, 규칙을 재정의해야 할 수도 있음



- 가장 먼저해야 할 것 => 애그리게잇 루트 엔티티 클래스 생성
  - 모든 애그리게잇 루트 엔티티는 전체 시스템에서 고유한 식별성을 가져야 한다.

```kotlin
public class Product : Entity {
  private string descprtion;
  private string name;
  private ProductId productId;	//TenantId와 ProductId 모두 변하지 않는 값 객체로 모델링했다.
  private TenantId tenantId;
}	
```



- 다음에는 애그리게잇을 찾는 데 필요한 본질적 속성이나 필드들을 찾는다.  위의 경우 Product는 description과 name 이 있다. 사용자들은  각각의 Product 를 찾기 위해 이들 중 하나 또는 둘 모두를 검색해 볼 수 있다.

  - 본질적 속성을 위해 읽기 접근자와 같은 간단한 행위를 추가해도 된다.

    

  - 객체지향 언어들을 사용하고 있다면, 내부 상태를 변경시키는 행위와 관련된 메서드들을 사용해서 값을 변경하면 된다.

    

  - 속성 쓰기 메서드를 공개시켜버린다면, 설정을 위한 로직이 모델 밖에 구현될 것이기 떄문에 빈약한 도메인으로 쉽게 빠질 수 있으니, 주의할 것

    

```kotlin
public class Product : Entity {
  private string description;
  private string name;
  private ProductId productId;	//TenantId와 ProductId 모두 변하지 않는 값 객체로 모델링했다.
  private TenantId tenantId;
  
  public string getDescription(...)
  
  ...
}
```



- DDD 를 사용할 때는 바운디드 컨텍스트 내의 보편언어를 모델링한다는 것을 항상 기억해야 한다.

  - 애그리게잇의 모든 부분은 보편언어에 따라 모델링 해야 한다. 단지 생각했던 부분들을 만드는 데 급급해서는 안 된다.

    

  - 모든 것이 조화를 이룰 수 있도록 도메인 전문가와 개발자들 사이에 긴밀한 협업이 필요하다.



***

### 추상화를 조심스럽게 선택하라.

- 효과적인 소프트웨어 모델은 항상 일을 하는 비즈니스의 방식을 고려한 일련의 추상화에 기반을 두고 있다. 모델링하는 각 개념마다 적절한 수준의 추상화를 선턱해야 한다.

  

- 보편언어와 관련된 가이드를 따른다면 적절한 추상화를 설정할 수 있다.

  

- 소프트웨어 개발자가 스크럼의 보편언어를 모델링하는 것에 관심을 갖지 않으면 여러 가지 문제점이 나타날 수 있다.

  - 소프트웨어 모델의 언어가 도메인 전문가의 멘탈 모델과 일치하지 않는다.

    

  - 추상화 수준이 너무 높아서 각 개별적인 형태의 세부 사항을 모델링하기 시작하면 어려운 상황에 빠질 것이다.

    

  - 각각의 클래스마다 특수한 경우를 정의할 것이고, 명백한 문제들에 대한 일반적인 접근을 통해 복잡한 클래스 계층 구조를 만들 것이다.

    

  - 우선적으로 중요하지 않은 문제를 해결하려다가 필요한 것보다 훨씬 많은 코드를 생산할 것이다.

    

  - 잘못된 추상화 수준은 심지어 사용자 인터페이스까지 영향을 미쳐 사용자에게 혼란을 주는 경우도 종종 발생한다.

    

  - 이로 인해 상당한 시간과 비용을 낭비할 수 있다.

    

  - 프로젝트 초반에 미래의 모든 요구를 생각하고 반영할 수는 없으므로, 새로운 스크럼 개념들은 앞으로도 계속 추가될 것이고, 기존 모델은 그 요구사항을 예견하는 데 실패할 수 밖에 없기 때문이다.

    

- 높은 수준의 추상화 구현이라는 덫에 현혹되지 말자. 팀이 정의한 도메인 전문가의 멘탈 모델에 따라 보편언어를 모델링 해야 한다.

  - 비즈니스가 지금 당장 요구하는 것을 모델링하면 ㄷ상당한 시간, 예산, 코드를 아끼고 곤란한 상황에 바지지 않을 수 있다.

  

***



